#include <glad/glad.h>
#include <GLFW/glfw3.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>

using namespace std;

//GLFWwindow  *window;

/*
VBO (Vertex Buffer Object) - это буфер, в котором хранятся вершины объекта. 
Каждая вершина содержит информацию о ее координатах, цвете, нормали и других параметрах.
VBO ускоряет отрисовку объекта, так как данные хранятся в видеопамяти, что позволяет быстро передавать их на видеокарту при отрисовке.

VAO (Vertex Array Object) - это буфер, который хранит состояние вершин, определенных в VBO. 
То есть, он содержит информацию о том, какие атрибуты вершин (координаты, цвета, нормали и т.д.) нужно использовать при отрисовке объекта.

EBO (Element Buffer Object) - это буфер, в котором хранится информация о порядке соединения вершин объекта. 
То есть, он определяет, какие вершины нужно соединить, чтобы получить треугольники или другие формы. 
Это позволяет эффективно использовать одни и те же вершины для отрисовки разных элементов объекта.
*/

/*
Вершинные шейдеры (Vertex Shaders) отвечают за обработку вершинных данных модели. 
Когда модель отображается на экране, она состоит из множества вершин, каждая из которых имеет определенные координаты в пространстве.

Вершинный шейдер может изменять положение, цвет, текстурные координаты и другие атрибуты вершин. 
Он также может выполнять сложные трансформации, такие как перемещение, вращение или масштабирование объектов. 
В результате работы вершинного шейдера, модель преобразуется и передается на следующий этап графического конвейера.

Фрагментные шейдеры (Fragment Shaders), также называемые пиксельными шейдерами, работают с отдельными фрагментами изображения, 
которые затем отображаются на экране. 
Фрагментом можно считать пиксель или часть пикселя, который будет виден на экране после всех процессов растеризации и моделирования. 
Фрагментные шейдеры определяют цвет и другие свойства каждого фрагмента на основе входных данных, таких как освещение, текстуры, тени и т. д. 
Они также могут выполнять операции, такие как смешивание цветов, создание эффектов прозрачности или добавление различных фильтров и постобработки.
*/

// Исходный код вершинного шейдера
const char* vertex_shader =
"#version 330 core\n" // Указываем версию OpenGL для использования
"layout (location = 0) in vec3 aPos;\n" // Определяем входной атрибут для позиции вершин
"layout (location = 1) in vec3 aColor;\n" // Определяем входной атрибут для цвета вершин
"out vec3 ourColor;\n" // Определяем выходную переменную для передачи цвета во фрагментный шейдер
"void main()\n" // Начало функции main
"{\n"
"   gl_Position = vec4(aPos, 0.7);\n" // Устанавливаем позицию вершины в пространстве
"   ourColor = aColor;\n" // Присваиваем цвет текущей вершине
"}\0"; // Завершающий нулевой символ


// Исходный код фрагментного шейдера
const char* fragment_shader =
"#version 330 core\n" // Указываем версию OpenGL для использования
"out vec4 FragColor;\n" // Определяем выходную переменную для цвета пикселя
"in vec3 ourColor;\n" // Определяем входную переменную для приема цвета из вершинного шейдера
"void main()\n" // Начало функции main
"{\n"
"   FragColor = vec4(ourColor, 0.7f);\n" // Устанавливаем цвет пикселя согласно полученному цвету из вершинного шейдера
"}\n\0"; // Завершающий нулевой символ
/*
формируем четырехмерный вектор позиции вершины, где aPos - это трехмерные координаты вершины, а 1.0 - это коэффициент преобразования w.
Коэффициент w используется для выполнения матричных преобразований над вершиной, таких как масштабирование, поворот и трансляция.
*/
static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, GLFW_TRUE);

    switch (key)
    {
    case GLFW_KEY_ESCAPE:
        glfwSetWindowShouldClose(window, GLFW_TRUE);
        break;
        /* case GLFW_KEY_SPACE:
             cur_icon_color = (cur_icon_color + 1) % 5;
             set_icon(window, cur_icon_color);
             break;
         case GLFW_KEY_X:
             glfwSetWindowIcon(window, 0, NULL);
             break;*/
    }
}

void drawGradientSquare()
{
    // Создаем идентификаторы буфера вершин и массива вершин
    GLuint vbo = 0; // Идентификатор буфера вершин
    GLuint vao = 0; // Идентификатор массива вершин

    // Определяем координаты вершин квадрата и их цвета
    float points[] = {
       -0.5f,  0.5f,  0.0f, 0.0f, 0.0f, 0.0f, // Вершина 1 (x, y, z, r, g, b)
        0.5f,  0.5f,  0.0f, 0.4f, 0.0f, 0.7f, // Вершина 2 (x, y, z, r, g, b)
       -0.5f, -0.5f,  0.0f, 1.0f, 1.0f, 1.0f, // Вершина 3 (x, y, z, r, g, b)
        0.5f, -0.5f,  0.0f, 0.2f, 0.2f, 0.2f  // Вершина 4 (x, y, z, r, g, b)
    };

    // Определяем порядок соединения вершин для формирования примитивов (в данном случае, треугольников)
    GLuint indices[] = {
        0, 1, 2, // Первый треугольник (вершины 1, 2, 3)
        1, 3, 2  // Второй треугольник (вершины 2, 4, 3)
    };


    // указывает, что создаваемый шейдер будет вершинным шейдером
    GLuint vs = glCreateShader(GL_VERTEX_SHADER);
    //  указывает, что создаваемый шейдер будет фрагментным шейдером
    GLuint fs = glCreateShader(GL_FRAGMENT_SHADER);
    GLuint shader_programme = glCreateProgram();
    // Создание и генерация буфера вершин (количество буферов, которые нужно создать 
    // / указатель на переменную, в которую будет записан идентификатор нового буфера вершин (VBO))
    glGenBuffers(1, &vbo);
    // Привязка буфера вершин к контексту OpenGL
    // тип буффера и идентификатор буфера вершин, который нужно привязать
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    // Загрузка данных в буфер вершин
    // тип / размер данных, которые нужно загрузить в буфер / указатель на данные, которые нужно загрузить в буфер вершин /
    // / как данные будут использоваться в приложении (здесь это GL_STATIC_DRAW, что означает, что данные являются статическими и не будут изменяться).
    glBufferData(GL_ARRAY_BUFFER, sizeof(points), points, GL_STATIC_DRAW);

    // Создает один вершинный массив и возвращает его идентификатор в переменную vao
    glGenVertexArrays(1, &vao);
    // Привязывает вершинный массив с идентификатором vao к контексту OpenGL
    glBindVertexArray(vao);
    // Включение использования атрибута с индексом 0
    // В контексте OpenGL это обычно означает передачу координат вершин в вершинный шейдер для отображения объектов на экране.
    glEnableVertexAttribArray(0);
    // Привязывает буфер вершин с идентификатором vbo к текущему вершинному массиву.
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    // Установка указателя на атрибут с индексом 0
    //  индекс текущего атрибута / количество элементов в атрибуте (3 коорд) / тип данных в атрибуте / нормализация данных не требуется
    // / шаг между атрибутами в байтах / смещение от начала буфера вершин до начала атрибута
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
    // Включение использования атрибута с индексом 0
    glEnableVertexAttribArray(0);
    // Установка указателя на атрибут с индексом 1
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
    // Включает использование атрибута с индексом 1 для текущего вершинного массива.
    glEnableVertexAttribArray(1);
    /*
    мы настраиваем атрибут вершины в позиции атрибута 1. Значения цвета имеют размер 3 с плавающей запятой, и мы не нормализуем значения.
    Чтобы получить следующее значение атрибута (например, следующий компонент x вектора положения) в массиве данных, 
    нам нужно переместить 6 чисел с плавающей запятой вправо: три для значений положения и три для значений цвета. 
    Это дает нам значение шага, в 6 раз превышающее размер числа с плавающей запятой в байтах (= 24 байта).
    Кроме того, на этот раз нам нужно указать смещение. Для каждой вершины первым идет атрибут позиции позиции, поэтому мы объявляем смещение, равное 0. 
    Атрибут цвета начинается после данных позиции, поэтому смещение равно 3 * sizeof(float) в байтах (= 12 байт).
    */

    // Создание и генерация буфера элементов
    GLuint ebo;
    glGenBuffers(1, &ebo);
    // Привязка буфера элементов к контексту OpenGL
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
    // Загрузка данных в буфер элементов
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

    // Загрузка и компиляция вершинного шейдера
    glShaderSource(vs, 1, &vertex_shader, NULL);
    glCompileShader(vs);

    // Загрузка и компиляция фрагментного шейдера
    glShaderSource(fs, 1, &fragment_shader, NULL);
    glCompileShader(fs);

    // Присоединение фрагментного и вершинного шейдеров к программе шейдеров
    glAttachShader(shader_programme, fs);
    glAttachShader(shader_programme, vs);
    // Связывание программы шейдеров
    glLinkProgram(shader_programme);

    // Установка текущей программы шейдеров
    glUseProgram(shader_programme);
    // Привязка вершинного массива к контексту OpenGL
    glBindVertexArray(vao);
    // Отрисовка элементов с использованием треугольников
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

}

// Когда пользователь меняет размер окна, окно просмотра также должно быть скорректировано, требуя функцию обратного вызова
void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
    // Первые два параметра функции glViewport управляют положением нижнего левого угла окна, 
    // а третий и четвертый параметры контролируют ширину и высоту окна рендеринга
    glfwSetKeyCallback(window, key_callback);
    glfwGetFramebufferSize(window, &width, &height);
    glViewport(0, 0, width, height);
}
// Объявляем функцию, чтобы определить, нажата ли конкретная клавиша
void processInput(GLFWwindow* window) {
    // Проверка, нажимает ли пользователь клавишу возврата (Esc) (если не нажата, glfwGetKey вернет GLFW_RELEASE, если нажата, GLFW_PRESS)
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
        glfwSetWindowShouldClose(window, true);
    }
}

int main(int argc, char** argv)
{ // Инициализация GLFW/Эта функция настраивает библиотеку для работы/если завершилась то всё хорошо
    glfwInit();

    // Установить номер основной версии OpenGL (Major) и номер вспомогательной версии (Minor) в 3
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);

    // Использование режима ядра (Core-profile)
    // Запрашиваем создание контекста OpenGL в строгом "ядре" функций, исключая устаревшие функции и возможности.
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    // Если это система MacOS, вам понадобится следующая строка кода для работы конфигурации
//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);

     // Создать объект окна
    // 4 и 5 Эти параметры (не NULL) позволяют создавать несколько окон, которые могут использовать одни и те же данные OpenGL, такие как текстуры или буферы
    GLFWwindow* window = glfwCreateWindow(900, 700, "lab 3", NULL, NULL);
    if (window == NULL) {
        cout << "Failed to create GLFW window" << endl;
        glfwTerminate();
        return -1;
    }
    // сообщает библиотеке GLFW, что окно, которое мы передаем ей в качестве аргумента (в данном случае window), 
    // должно быть установлено как основной контекст для рисования в текущем потоке выполнения программы.
    glfwMakeContextCurrent(window);

    // GLAD используется для управления указателем функции OpenGL, нам нужно инициализировать GLAD перед вызовом любой функции OpenGL
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        cout << "Failed to initialize GLAD" << endl;
        return -1;
    }

    // Зарегистрируем определенную функцию обратного вызова и сообщаем GLFW вызывать эту функцию при каждом изменении размера окна
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);


    // Визуализация цикла
    /*
    при каждой итерации цикла будет происходить очистка экрана, отрисовка квадрата и обмен цветовыми буферами.
    шейдеры и буферы не будут пересоздаваться при каждой итерации цикла. Они создаются и настраиваются один раз при инициализации, 
    а затем используются повторно на каждой итерации цикла для отрисовки квадрата.
    */
    while (!glfwWindowShouldClose(window)) {

        // Проверить, нажата ли конкретная клавиша, и обрабатывать ее каждый кадр
        processInput(window);

        // функция установки состояния, используемая для установки цвета, используемого для очистки экрана
        glClearColor(0.2f, 0.2f, 0.2f, 0.0f);
        // функция использования состояния, которая использует текущее состояние для очистки экрана с указанным цветом
        glClear(GL_COLOR_BUFFER_BIT);
        //triang(); - запускаем отрисовку треугольника. Работает именно в этом месте!
        //triang();
        drawGradientSquare();
        // Функция glfwSwapBuffers будет обмениваться цветовыми буферами
        glfwSwapBuffers(window);
        // Функция glfwPollEvents проверяет, запущены ли какие-либо события
        glfwPollEvents();
    }

    // Освободить все ресурсы, выделенные ранее
    glfwTerminate();

    return 0;
}